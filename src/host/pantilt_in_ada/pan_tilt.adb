--
--  Copyright (c) 2015, John Leimon <jleimon@gmail.com>
--
--  Permission to use, copy, modify, and/or distribute this software for any
--  purpose with or without fee is hereby granted, provided that the above copyright
--  notice and this permission notice appear in all copies.
--
--  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
--  TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN
--  NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR
--  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
--  PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
--  ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
--
--  Pixy Tracking Demo - Ada Version --
--
--  To Build:
--
--  gnatmake pan_tilt.adb -aO/usr/local/lib -aO/usr/lib/gcc/x86_64-linux-gnu/4.8/ -aO/usr/lib/x86_64-linux-gnu/ -largs -lpthread -lpixyusb -lboost_system -lboost_chrono -lboost_thread -lstdc++ -lusb-1.0

WITH ADA.TEXT_IO;    USE ADA.TEXT_IO;
WITH INTERFACES;     USE INTERFACES;
WITH INTERFACES.C;   USE INTERFACES.C;
WITH PIXY;           USE PIXY;
WITH SIGINT_HANDLER; USE SIGINT_HANDLER;

FUNCTION PAN_TILT RETURN INT IS

   SUCCESS : CONSTANT := 0;
   

   PIXY_X_CENTER   : CONSTANT SENSOR_WIDTH  := (SENSOR_WIDTH'LAST - SENSOR_WIDTH'FIRST) / 2;
   PIXY_Y_CENTER   : CONSTANT SENSOR_HEIGHT := (SENSOR_HEIGHT'LAST - SENSOR_HEIGHT'FIRST) / 2;
   PIXY_RCS_CENTER : CONSTANT RCS_POSITION  := (RCS_POSITION'LAST - RCS_POSITION'FIRST) / 2;

   -- PROPORTION-INTEGRAL-DERIVATIVE (PID) CONTROL PARAMETERS --

   AZIMUTH_PROPORTIONAL_GAIN  : CONSTANT INTEGER := 400;
   AZIMUTH_DERIVATIVE_GAIN    : CONSTANT INTEGER := 300;
   ALTITUDE_PROPORTIONAL_GAIN : CONSTANT INTEGER := 500;
   ALTITUDE_DERIVATIVE_GAIN   : CONSTANT INTEGER := 400;

   TYPE GIMBAL IS RECORD
      POSITION             : RCS_POSITION;
      ERROR                : RCS_ERROR;
      PREVIOUS_ERROR       : RCS_ERROR;
      PREVIOUS_ERROR_VALID : BOOLEAN;
   END RECORD;

   TYPE AZIMUTH_TYPE IS NEW GIMBAL;
   TYPE ALTITUDE_TYPE IS NEW GIMBAL;

   BLOCK            : ALIASED PIXY.BLOCK;

   AZIMUTH          : AZIMUTH_TYPE;
   ALTITUDE         : ALTITUDE_TYPE;

   PIXY_INIT_STATUS : INT;
   BLOCKS_COPIED    : INT;
   RESULT           : INT;
   FRAME_INDEX      : INTEGER;

   ------------------------
   -- INITIALIZE_GIMBALS --
   ------------------------

   PROCEDURE INITIALIZE_GIMBALS IS
   BEGIN
     AZIMUTH.POSITION              := PIXY_RCS_CENTER;
     AZIMUTH.PREVIOUS_ERROR_VALID  := FALSE;
     ALTITUDE.POSITION             := PIXY_RCS_CENTER;
     ALTITUDE.PREVIOUS_ERROR_VALID := FALSE;
   END INITIALIZE_GIMBALS;

   --------------------
   -- UPDATE_AZIMUTH --
   --------------------

   PROCEDURE UPDATE_AZIMUTH IS
     P_GAIN      : INTEGER RENAMES AZIMUTH_PROPORTIONAL_GAIN;
     D_GAIN      : INTEGER RENAMES AZIMUTH_DERIVATIVE_GAIN;
     VELOCITY    : INTEGER;
     ERROR_DELTA : RCS_ERROR;
   BEGIN
     IF AZIMUTH.PREVIOUS_ERROR_VALID THEN
       ERROR_DELTA := AZIMUTH.ERROR - AZIMUTH.PREVIOUS_ERROR;
       VELOCITY    := (INTEGER(AZIMUTH.ERROR) * P_GAIN + INTEGER(ERROR_DELTA) * D_GAIN) / 1024;

       -- UPDATE AZIMUTH POSITION --
       IF INTEGER(AZIMUTH.POSITION) + VELOCITY > INTEGER(RCS_POSITION'LAST) THEN
         AZIMUTH.POSITION := RCS_POSITION'LAST;
       ELSIF INTEGER(AZIMUTH.POSITION) + VELOCITY < INTEGER(RCS_POSITION'FIRST) THEN
         AZIMUTH.POSITION := RCS_POSITION'FIRST;
       ELSE
         AZIMUTH.POSITION := RCS_POSITION(INTEGER(AZIMUTH.POSITION) + VELOCITY);
       END IF;
     ELSE
       AZIMUTH.PREVIOUS_ERROR_VALID := TRUE;
     END IF;
     AZIMUTH.PREVIOUS_ERROR := AZIMUTH.ERROR;
   END UPDATE_AZIMUTH;

   ---------------------
   -- UPDATE_ALTITUDE --
   ---------------------

   PROCEDURE UPDATE_ALTITUDE IS
     P_GAIN      : INTEGER RENAMES ALTITUDE_PROPORTIONAL_GAIN;
     D_GAIN      : INTEGER RENAMES ALTITUDE_DERIVATIVE_GAIN;
     VELOCITY    : INTEGER;
     ERROR_DELTA : RCS_ERROR;
   BEGIN
     IF ALTITUDE.PREVIOUS_ERROR_VALID THEN
       ERROR_DELTA := ALTITUDE.ERROR - ALTITUDE.PREVIOUS_ERROR;
       VELOCITY    := (INTEGER(ALTITUDE.ERROR) * P_GAIN + INTEGER(ERROR_DELTA) * D_GAIN) / 1024;

       -- UPDATE ALTITUDE POSITION --
       IF INTEGER(ALTITUDE.POSITION) + VELOCITY > INTEGER(RCS_POSITION'LAST) THEN
         ALTITUDE.POSITION := RCS_POSITION'LAST;
       ELSIF INTEGER(ALTITUDE.POSITION) + VELOCITY < INTEGER(RCS_POSITION'FIRST) THEN
         ALTITUDE.POSITION := RCS_POSITION'FIRST;
       ELSE
         ALTITUDE.POSITION := RCS_POSITION(INTEGER(ALTITUDE.POSITION) + VELOCITY);
       END IF;
     ELSE
       ALTITUDE.PREVIOUS_ERROR_VALID := TRUE;
     END IF;
     ALTITUDE.PREVIOUS_ERROR := ALTITUDE.ERROR;
   END UPDATE_ALTITUDE;

BEGIN

   PUT_LINE("+ PIXY TRACKING DEMO STARTED +");

   INITIALIZE_GIMBALS;

   PIXY_INIT_STATUS := PIXY.INIT;
   FRAME_INDEX      := 0;

   -- WAS THERE AN ERROR INITIALIZING PIXY? --
   IF PIXY_INIT_STATUS /= 0 THEN
     PUT("ERROR: PIXY_INIT() [" & INT'IMAGE(PIXY_INIT_STATUS) & "] ");
     PIXY.ERROR(PIXY_INIT_STATUS);
     RETURN PIXY_INIT_STATUS;
   END IF;

   TRACKING_LOOP:
   WHILE NOT SIGINT LOOP

     -- WAIT FOR NEW BLOCKS TO BE AVAILABLE --
     WAITING_LOOP:
     WHILE PIXY.BLOCKS_ARE_NEW = 0 AND NOT SIGINT LOOP
        NULL;
     END LOOP WAITING_LOOP;

     -- GET BLOCKS FROM PIXY --
     BLOCKS_COPIED := GET_BLOCKS(1, BLOCK'ACCESS);

     IF BLOCKS_COPIED < 0 THEN
       -- ERROR: PIXY.GET_BLOCKS --
       PUT("ERROR: PIXY_GET_BLOCKS() [" & INT'IMAGE(BLOCKS_COPIED) & "]");
       PIXY.ERROR(BLOCKS_COPIED);
     END IF;

     IF BLOCKS_COPIED > 0 THEN

       -- CALCULATE THE DIFFERENCE BETWEEN THE CENTER OF PIXY'S --
       -- FOCUS AND THE TARGET.                                 --
       AZIMUTH.ERROR  := RCS_ERROR(PIXY_X_CENTER) - RCS_ERROR(BLOCK.X);
       ALTITUDE.ERROR := RCS_ERROR(BLOCK.Y) - RCS_ERROR(PIXY_Y_CENTER);

       -- APPLY CORRECTIONS TO THE AZIMUTH/ELEVATION WITH THE GOAL --
       -- OF PUTTING THE TARGET IN THE CENTER OF PIXY'S FOCUS.     --
       UPDATE_AZIMUTH;
       UPDATE_ALTITUDE;

       RESULT := RCS_SET_POSITION(RCS_AZIMUTH_CHANNEL, UINT16(AZIMUTH.POSITION));
       IF RESULT < 0 THEN
         PUT("ERROR: PIXY_RCS_SET_POSITION() [" & INT'IMAGE(RESULT) & "]");
         PIXY.ERROR(RESULT);
       END IF;

       RESULT := RCS_SET_POSITION(RCS_ALTITUDE_CHANNEL, UINT16(ALTITUDE.POSITION));
       IF RESULT < 0 THEN
         PUT("ERROR: PIXY_RCS_SET_POSITION() [" & INT'IMAGE(RESULT) & "]");
         PIXY.ERROR(RESULT);
       END IF;

       IF FRAME_INDEX MOD 50 = 0 THEN
         PUT_LINE("FRAME " & INTEGER'IMAGE(FRAME_INDEX) & ":");
         PUT_LINE("  SIG: " & UINT16'IMAGE(BLOCK.SIGNATURE) &
                  "  X:"      & UINT16'IMAGE(BLOCK.X) &
                  "  Y:"      & UINT16'IMAGE(BLOCK.Y) &
                  "  WIDTH:"  & UINT16'IMAGE(BLOCK.WIDTH) &
                  "  HEIGHT:" & UINT16'IMAGE(BLOCK.HEIGHT));
       END IF;

       FRAME_INDEX := FRAME_INDEX + 1;
     END IF;
   END LOOP TRACKING_LOOP;

   PUT_LINE ("+ PIXY TERMINATING +");
   PIXY.CLOSE;

   RETURN SUCCESS;
END PAN_TILT;
